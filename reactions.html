<p><link rel="stylesheet" href="github.css"/></p>

<h1>Formal Semantics & Notational Machine (Brown CSCI 2951y)</h1>

<p>(Justin Pombrio)</p>

<p><a href="reactions.html">Class-ly reactions</a></p>

<p><a href="sorva.html">Sorva</a></p>

<p><a href="notes.html">Other Readings</a></p>

<p><a href="constructivism-views.html">Constructivism in Mystery Languages</a></p>
<p><link rel="stylesheet" href="github.css"/></p>

<h1>Class-ly Reactions<br/>
(Interest, surprise, disagreement)</h1>

<p><a href="notes.html">(Class notes are here.)</a></p>

<h1>Day 1</h1>

<h3>A Surprise</h3>

<p>In the US, CS is classified as <em>vocational</em>, not <em>STEM</em>.</p>

<h3>A Captivation</h3>

<p>The three perspectives.</p>

<h3>A Disagreement</h3>

<p>Says that intro CS is harder than intro math or an intro science.
The argument is that students come in with (at least some) real-life
knowledge that applies. But students have no experience with
unambiguous languages.</p>

<p>However, math is like that, except that you don't have a computer to
check your work.</p>

<h3>A Question</h3>

<p>Rainfall problem: how do results differ when students test their
program vs. not?</p>

<h3>A Confusion</h3>

<p><em>Computational Literacy</em> (1.2.4). This section seems to mix up:</p>

<ul>
<li>The internet, which is indeed akin to the printing press</li>
<li>Word processing and such</li>
<li>Computational literacy</li>
</ul>

<p>"We see coding as a new way for people to organize, express, and share
their ideas."</p>

<p>What exactly does this sharing look like? It's relevant for
scientists, but that was already covered in "computational thinking".
Is it people programming in spreadsheets that they share? What do
actual example look like?</p>

<blockquote>
  <p>animated greeting cards
spreadsheet formulas
tweaking/appreciating websites
musicians using MaxMSP</p>
</blockquote>

<h3>A Confusion</h3>

<p>Pg. 37: What is "process" here? Earlier in the book, it was <em>defined</em>
as being what a program does, but here it's supposed to be broader
than CS.</p>

<h3>A Surprise</h3>

<p>Apparently LOGO taught poorly. I'm curious to see the studies that
killed it, what the language's aims were and what the results were.
(My guess: the aims presented for LOGO were way out of whack with what
one could reasonably expect to learn from the language.)</p>

<h1>Day 2</h1>

<h3>A Question</h3>

<p><strong>Common Goal</strong> of intro CS: students should be "capable of developing a
(small) program which solves a problem that has been expressed vaguely
in non-programming terms."</p>

<p>Is the <em>common goal</em> realistic?</p>

<h3>A Captivation</h3>

<p>I saw a confusion about probability in a Nautilus article today that I
only know how to explain if the author (a physicist) believes that the
probability of an event is independent of your knowledge. This is a
<em>really</em> fundamental mistake. (It's also why there's a picture of a
pipe on my wall.) Are there misconceptions like this that experienced
computer scientists live with?</p>

<p>And intro CS students seem to have just about every possible
misconception. Does "learning" consist of picking a random hypothesis
consistent with the evidence and believing it until it's unequivocally
disproven?</p>

<p>(For curiosity, the article is
<a href="http://cosmos.nautil.us/feature/120/the-crisis-of-the-multiverse">here</a>;
the "sleeper" argument begins with "The issue came into focus via..."
and ends at "The fact that two logical lines of argument yield
contradictory answers tells us that the problem is not well-defined."
(they don't).)</p>

<h1>Day 3</h1>

<h3>An Interest</h3>

<p>(Knowledge Representation, by Markman)</p>

<p>Why should we care what knowledge representation people use? The intro
gives a <em>beautiful</em> example, where an rule described using letters and
numbers is completely unintuitive but the same rule described using
drinking age is completely intuitive. (Even to me.)</p>

<h3>A Surprise</h3>

<p>"There is considerable empirical evidence that plans and
plan schemas are the basic cognitive chunks used in designing and
understanding programs."</p>

<h3>A disagreement</h3>

<p>(Camels and Humps: a Retraction)</p>

<p>Why was this teacher's reaction to a test that predicts programming
performance and doesn't improve over time "these students can't
learn to program" rather than "Sweet: maybe I can use this to figure
out why my students aren't learning to program!"?</p>

<p>"That document was very misleading and, because web documents persist,
it continues to mislead to this day."</p>

<p>That's because it's <em>hosted</em> on Dehnadi's <em>website</em>, which doesn't
  mention the <em>retraction</em>.</p>

<h1>Day 4</h1>

<h3>An Interest</h3>

<p>"Researchers vary in how they describe the internal structure of
mental models". Translation: no one has any idea how mental models are
represented.</p>

<h3>A Surprise</h3>

<p>I've always thought state was confusing. I'm glad it's not just me;
it's been shown to almost universally confuse students too. (Even
more-so than other topics.)</p>

<h3>A Disagreement</h3>

<p>There was an example of a simple C-style for-loop, and a
misinterpretation that violated De Kleer &amp; Brown's robustness
principle for mental representations. It was pointed out that the
student's mental model described how for-loops were used in practice,
but not what they really meant. I'd blame the loop more than the
student, though; "for..in" captures practically all of the use-cases
of "for(;;)", so why should a student learn the full meaning?</p>

<h1>Day 5</h1>

<h3>An Interest</h3>

<p>A core <em>uncontroversial</em> constructivist belief is that:</p>

<blockquote>
  <p>We learn by combining prior knowledge with new experience.</p>
</blockquote>

<p>Interestingly, this is a rather precise description of Bayesianism.</p>

<h3>A Surprise</h3>

<p>I recently came across a very clear description of truth in
<a href="http://yudkowsky.net/rational/the-simple-truth">this story</a>.
I'm surprised to have to use it.</p>

<p>"<strong>Reality</strong> is that which, when you stop believing it, doesn't go
away." - Philip K. Dick</p>

<p>"<strong>Truth</strong> is the correspondence between one's beliefs about reality
and reality." - LessWrong Wiki</p>

<h3>A Disagreement</h3>

<p>Most of the constructivist beliefs about how best to teach seemed to
be unsupported by evidence. If your new worldview makes inaccurate
predictions...</p>

<p>For instance, is there any evidence for knowledge-as-theory or
knowledge-as-elements?</p>

<h1>Day 6</h1>

<h3>An Interest</h3>

<p>Here's an interesting result. Students describing recusrion fell into
three categories: "A) as a construct in a programming language B) as a
means of bringing about repetition, and C) conceptually as
self-reference that enables a function to make use of itself".</p>

<h3>A Surprise</h3>

<p>The definition of variation theory:</p>

<p><strong>Variation Theory:</strong> "The assumption is that if we want to make the
student think in a certain way about something, it should be useful to
know what other ways there are to think about it."</p>

<p>Seems closely related to concept inventories. The examples look
similar as well, if coarser.</p>

<h3>A Disagreement</h3>

<p><strong>Question:</strong> Does leading students into certain ways of experiencing
things improve learning outcomes? If not, why should we pay any
attention to Phenomenologic research (beyond curiosity)?</p>

<h3>A Note</h3>

<p>Chapters 6 and 7 have scattered statements that seem obviously false,
which makes me think I don't understand how the quoted authors are
using words. I also don't understand the philisophical differences
between Phenomenologists and Constructivists (though what they <em>do</em> is
quite distinct).</p>

<h1>Day 7</h1>

<h3>An Interest</h3>

<p>Muller's paper gives 7 examples of algorithmic patterns. Five of them
are commonly library functions.</p>

<p>(The list: <code>len</code>, <code>fold</code>, <code>exists</code>, <code>all</code>, <code>map</code>(?). Plus
num-to-digits (not common) and "extreme value computation" (what is
that?).</p>

<h3>A Surprise</h3>

<p>I didn't expect the the students in Castro's study to perform <em>quite</em>
so badly. Many students had the idea to write helper functions, and
most used htdp templates. Did any of them actually write a correct
helper function, though?</p>

<h3>A Disagreement</h3>

<p>In Muller's paper, they used POI to successfully teach students to
decompose problems and then had them glom them all together into one
function. The <em>expert</em> solution was all mixed together instead of
being decomposed into separate meaningful functions. I would recommend
against hiring a developer that wrote code like that. This makes me
sad.</p>

<h1>Day 8</h1>

<h3>An Interest</h3>

<p>In the Izu paper, I liked the term "building block". It recognizes
that the schemas that students learn (and could therefore possibly
recall) are course specific.</p>

<h3>A Disagreement</h3>

<p>Both of the papers seemed to revolve around loops, numbers, and arrays.
Even people's names were represented with numbers. And the problems
all seemed artificially geared toward this kind of data. How common is
this in intro cs? (Izu section 2.2 suggests "quite".)</p>

<h3>A Question</h3>

<p>Is seems odd to me that us total novices are commenting so much and
asking so few questions. What would people think of doing "Interest,
Disagreement, Question" instead of "Surprise, Interest, Disagreement"?</p>

<h1>1-3-17</h1>

<h3>Interest</h3>

<pre><code>The interview technique for individual students should be transformed
into a class discussion technique for probing misconceptions and
stimulating interaction among the students to induce conceptual
change. When skillfully done, this is one of the most effective means
of dealing with misconceptions.
</code></pre>

<p>I'm curious what this discussion would look like.</p>

<h3>Surprise</h3>

<pre><code>The evidence that large Inventory gains are possible is now sufficient
for us to conclude that, for effective instruction, only the posttest
score counts.
</code></pre>

<p>This is fantastic. It also sounds like a good metric for a concept
inventory: everyone's bad at it, and the questions are simple, but
they predict performance well.</p>

<h3>Diagreement</h3>

<p>"Identifying Student Misconceptions of Programming"</p>

<p>An example of the "Semantics to semantics" misconception says:</p>

<pre><code>For example, when examining a list of Java variable definitions and
declarations whose interrelationships are unstated (see Appendix:
Problem 1), Student2 explains: “And then have the names of the songs
in here, which – but this would be stored in library, I'm assuming, or
in the library class. I don't know how they're linked together
exactly.”
</code></pre>

<p>The paper says that "details about the relationship and operation of
code samples [... were] neither given nor implied". But they were
<em>strongly</em> implied by the prompt:</p>

<pre><code>You are setting up a database of information about all the songs
you own.  Each song has certain information associated with it.
Diagram (or use pseudo-code) how this information would be stored
in memory:
</code></pre>

<p>"This information" is clearly referring to each song's "certain
information", which is also the information in the database that <em>you</em>
are setting up. The prompt asks how this information <em>would</em> be stored
in memory. In the database that <em>you</em> are setting up.</p>

<p>And you're supposed to think that there are no relationships between
the code samples?</p>

<p>In another example:</p>

<pre><code>In another example, with a different problem (see Appendix: Problem
2b), Student3 makes incorrect assumptions about connections between
variables to the extent that the student makes a mistake concerning
the types of the variables. As a result, the student places Objects of
different types in an array whose type matches none of them: “And so
because there’s two arrays, cheese and meats, uh, all those turkey and
ham and roast beef are gonna be sorted into the meats array.”
</code></pre>

<p>That's what I assumed too. Presumably those are subclasses of Meat;
otherwise why is there an array of Meats? What good is a Meat array if
you can't put Turkey in it?</p>

<p>These are literally the worst programming question prompts I've ever
seen, and the authors' aggressive interpretation of student responses
makes me question the other misconceptions they've found.</p>

<h1>1-5-17</h1>

<h3>Interest</h3>

<p>Boulay points out some big issues with putting variables in boxes.</p>

<p>"After all, most boxes hold more than one thing."</p>

<p>"After all, if one has not put anything into a box, it's empty, which
is sort of like zero."</p>

<p>These problems were known so early; why do we still go about it?</p>

<h3>Surprise</h3>

<p>I hadn't thought much about the fact that a notional machine should be
inspectible, but of course it should! And the language you're using
should use the same terminology you're being taught, otherwise it
looks like the teacher's lying: they've told you one thing, but that
error message says something different.</p>

<p>It's <em>much</em> easier to learn about something you interact with a lot.</p>

<h3>Questions</h3>

<p>I'm still interested in the fate of LOGO. Where can I find the
original study results?</p>

<h1>1-20-17</h1>

<h3>Surprise</h3>

<p>I realized when reading Kohn's variable paper that most of the
misconceptions discussed were <em>eminently</em> reasonable ways for a
language to work, and in fact almost all of them appear in existing
languages:</p>

<ul>
<li>Assignments are symmetric / are equations (Mathematica)</li>
<li><code>max</code> automatically holds the max (This is the sole exception: we'd
sure like the computer to program for us, but not even program
synthesis tries to interpret variable names.)</li>
<li>Vars are empty after access (This happens with channels and with
linear types)</li>
<li>Vars can hold more than one value or have a memory (I'm not thinking
of a concrete example where a language does this, but, e.g., having
queues of messages is common.)</li>
<li>Vars hold unevaluated expressions (Haskell)</li>
<li>Vars are linked together (Aliasing: languages used to do this)</li>
</ul>

<h3>Interest</h3>

<p>I liked Kohn's conclusion:</p>

<pre><code>Applied to our case, it might simply not be enough to use
visualizations and show students how the notional machine
works. *In order to build viable mental models, students
must be prompted to interactively work with the notional
machine and recognize differences from their current mental
models.* A possible way to achieve this interaction could be
to teach students how to trace a program with paper and
pencil, and check the obtained results. [emphasis mine]
</code></pre>

<p>I can't help but think of mystery languages: they could reify
student's possible misconceptions. I'm picturing a mystery language
per known misconceptions, and asking CS1 students to explain their
differences. This would force them to very directly confront the
relevant distinctions. It might also give them hypothetical-language
envy: "Why can't I use the language that solved equations?", which
isn't necessarily a bad thing.</p>

<p>On the other hand, this could also be a terrible idea: after all, we
don't teach physics by explaining in detail 10 ways the world could
work, and then tossing 9 of them out.</p>

<h1>1-22-17</h1>

<h3>Disagreement</h3>

<p>In the Pascal averaging example, where the student was supposedly
"believing that the programming language knows more about her
intentions then it possibly can", I feel like she was answering the
question (weather "1a" and "2a" were the 'same kind of statement')
<em>semantically</em>, but being judged assuming it was meant <em>syntactically</em>.
I.e., she answered weather you should think of them as the same kind
of statement from a program design standpoint, which seems like a
reasonable enough thing to do.</p>

<h3>Question</h3>

<p>I wonder weather the "superbug" has gotten better over time, as
students now come in having interacted with lots of deterministic
software? Although, even if it has, it will get worse again.
Gmail knows when you meant to send an attachment, and will remind you
about it.</p>

<h3>Interesting</h3>

<p>Again, while they are presented as misconceptions, a lot of the things
that students think the computer will do would---excluding the
infeasible ones---would make for a reasonable programming language.</p>

<h1>3-23-17</h1>

<h3>Question</h3>

<p>Page 42: how were metacognitive skills measured?</p>

<h3>Disagreement</h3>

<p>Most of the results seem explainable by "everyone rates themselves as
60th percentile until proven otherwise".</p>

<h3>Interest</h3>

<p>The paper showed a couple notable things:</p>

<ul>
<li>Predictions 1&amp;2: the incompetant can't judge their own or other
people's ability well (not terribly surprising).</li>
<li>Prediction 3: the incompetant don't learn anything from viewing
others' answers, but the competent do.</li>
<li>Prediction 4: training helps self-assesment.</li>
</ul>

<p>Big warning: notice that most of the data is insignificant. E.g.,
don't read too much into the flow of the line graphs.</p>

<h2>4-3-17</h2>

<h3>Disagreement: Garner's Code Completion</h3>

<p>I don't see an actual argument that <em>program completion</em> is a good way
to teach. The relevent parts of the approach seem to be (i) preventing
students from copy-pasting, and (ii) debugging support. Also, where
did the story of how the student learned to program come from? It was
filled with what appear to be gueses about his state of mind.</p>

<h3>Surprise: Denny et al. on Parsons Problems</h3>

<p>This paper argues against code tracing. Student: "In the real world,
you wouldn't trace the numbers, you'd run the program."</p>

<p>Come to think of it, I'm not sure how I reason about programs as I
write them, but I'm pretty sure it doesn't look like code tracing. The
students don't seem to think it's a natural thing to do, either. Is
there another way to teach reasoning about programs? Perhaps it looks
more like plan composition, but reading rather than writing?</p>

<h3>Question: Parson on Parsons Problems</h3>

<p>A lot of these focused on "activity diagrams" (i.e., flowcharts?).
This seems like an approach to teaching state, which is known to be
very difficult to teach: does it work at all?</p>

<h3>Parson's Programming Puzzles</h3>

<p>This addresses a concern I've had about Htdp: it starts off slowly and
in rote. Do students find it boring? (OK: reading further, it doesn't
help teach syntax at all.)</p>

<p>This approach has the advantage of teaching <em>parts</em> of programming,
reducing the overwhelming number of things beginning students need to
deal with at once (syntax, planning, debugging).</p>

<p>14/17: provide more detail about the errors made.</p>

<p>Is there knowledge about how useful "activity diagrams" (flowcharts)
are for understanding state?</p>

<h3>Evaluating a New Exam Question: Parsons Problems</h3>

<p>Nearly as much correlation between tracing &amp; writing code as Parson's and
writing code (0.37 vs 0.53).</p>

<p>"Indications of structure can be used to make an 'easier' problem on
an exam." - is this just introducing a side-channel to figuring out
the answers?</p>

<p>Student: "In the real world, you wouldn't trace the numbers, you'd run
the program."</p>

<h3>The Code Mangler: Evaluating Coding Ability Without Writing any Code</h3>

<p>Is speed and consistency really the best metric for grading?</p>

<h1>April 6</h1>

<h3>Disagreement: Lee&amp;Ko'11</h3>

<p>The primary claim in the abstract, "those in the experimental
condition (with a personable Gidget) completed significantly more
levels in a similar amount of time" is misleading. It's <em>really</em>
suggestive that they completed levels faster, which is not supported
by the paper's evidence.</p>

<h3>Question: Lee&amp;all'14</h3>

<p>The major claim of this paper is that students learned to code using
Gidget, but there are only vague descriptions of the sorts of things
involved in its programs. What do the levels look like?</p>

<p>You can play Gidget online! <a href="Gidget">http://www.helpgidget.org/</a></p>

<h3>Interesting: Lee&amp;Ko'15</h3>

<p>I hadn't made this connection before, but level designers for computer
games ought to make good curriculum designers. Level design (for
single-player levels), for all games but especially puzzle games, is
almost entirely about teaching players (i) the mechanics of the game,
and (ii) to become more skilled at playing the game. They deftly
introduce new concepts and reinforce old concepts while staying at
exactly the right level of difficulty to be fun. And they do it with
little to no prose!  (I'm thinking of: Portal, The Talos Principle,
The Witness.)</p>

<h1>April 11</h1>

<h3>Disagreement: Reges' The mystery of b := b = false</h3>

<p>Again, there's this leap from "these questions correlate with student
performance" to "maybe this is a measure of innate ability". This
seems like a strange leap to make given that Reges (i) describes these
as code comprehension questions for important language constructs, and
(ii) says that in his experience, the ability to answer questions like
this is teachable.</p>

<p>There seems to be a very simple explanation for these results: (i)
most students can't trace code, (ii) code tracing is a good predictor
of overall performance, and (iii) the <em>only</em> way to figure out what
<code>b := b = false</code> will do is by code tracing.</p>

<h3>Interest: Fleury's Programming in Java: Student-Constructed Rules</h3>

<p>I like the phrase "student-constructed rules" instead of
misconceptions. All the examples seemed like reasonable
overgeneralizations of true rules, that could have been countered by
showing counterexamples (in the form of programs). Fleury seems to
agree:</p>

<p>"The students most often cited experience with programs as the most
important source of their knowledge of Java."</p>

<p>"By constructing sample programs with care, an instructor can avoid
inadvertently fostering common misconceptions."</p>

<h3>Question</h3>

<p>Has anyone attempted to make a repository of programs that act as
counterexamples to misconceptions? Like a concept-inventory-lite.</p>
