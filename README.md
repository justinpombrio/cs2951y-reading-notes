<link rel="stylesheet" href="tufte.css"/>

<h1>Reading Notes for Brown CS 2951y:<br/>
(Formal Semantics & Notational Machines)</h1>

(Justin Pombrio)

# Class Notes

**Mental model:** student's beliefs

**Notational machine:** a model of a language meant to aid students

**Concept inventory:** a set of misconceptions on a topic, as well as
  the correct understanding, that cover all of the common
  understandings that students come to. Can then tell which a student
  has via multiple-choice questions.

**Constructivism:** "learning by doing" / "discovery learning".
From this perspective, not having a curriculum when teaching could be
good.

# Reading Notes




## Qualify Your Quantifiers...Or, Exactly Who All Is CS4?

Do not conflate "CS for all students" with "CS in all schools".
CS for all students requires:

- that courses not be opt-in, or you lose equal representation, and
- support for the disabled, and of course
- enough teachers to teach every student.

This is *much* harder than just adding after-school clubs.




## Learner-Centered Design of Computing Education

### Chapter 1: Computing for Everyone

**Computing:** broader than computer science.

**Computational Thinking:** the thought process involved in formulating
 problems and their solutions so that the solutions are represented in
 a form that can be effectively carried out by an
 information-processing agent.

Reasons we should teach CS:

- Jobs (most common citatation).
- We live in a world filled with software.
- Computational thinking.
- Computational literacy (???).
- Productivity (e.g. graphic designers, e.g. historians plotting
peoples' movement)
- Broadening representation (e.g. currently AP CS 20% female)

Perspectives of Teachers:

- **Apprenticeship** (experience, practice, assignments)
- **Transmission** (content)
- **Developmental** (differing needs & starting knowledge)

How to teach CS to all students:

- In the US, CS is classified as *vocational*, not *STEM*. Adds
  administrative challanges (e.g., separate, may not count for credit
  in some contexts).
- Consider that we're currently only teaching the top students.
- **learner-centered design**: tailor teaching to what students want
  to learn; to discover this you must do studies.


### Chapter 2: Measuring CS Knowledge

Studies show: students are *really bad* at programming
(e.g. rainfall, calculator, clock, FCS1).

Learning happens by **assimilation**: adding to existing perspective,
and **accomodation**: updating perspective.

**Knowledge transfer**: being able to apply knowledge in a domain
  different from the one you learned it in.

Learning to program is difficult because:

- There is no person in the machine to interpret what you meant
- What's happening is invisible
- Experts have blinds spots of "obvious" knowledge.

Why do students choose to program?

- **Situated Learning**: students choose topics whose communities they
  wish to join.
- **Expectancy-Value Theory**: students choose topics they think would
  provide utility and that they could succeed at. (See also
  complicated **Eccles** model.)

### Chapter 3: Using programming to Learn

We've largely failed at finding or imparting knowledge transfer into
or out of computing education. We only really know how to impart it
by teaching it directly in the transfer domain.

Some successes in teaching programming *and* other skills together.
Guzdial concludes that you should generally expect to teach only
enough programming for the other subject you're targetting, and expect
students to learn the other subject well, but not necessarily learn
much programming.

Some programming methods/environments discuessed:
LOGO, Smalltalk, ISDP, Emile, Bootstrap, Boxer.


# Reactions

## Day 1

### A Surprise

In the US, CS is classified as *vocational*, not *STEM*.

### A Captivation

The three perspectives.

### A Disagreement

Says that intro CS is harder than intro math or an intro science.
The argument is that students come in with (at least some) real-life
knowledge that applies. But students have no experience with
unambiguous languages.

However, math is like that, except that you don't have a computer to
check your work.

### A Question

Rainfall problem: how do results differ when students test their
program vs. not?

### A Confusion

*Computational Literacy* (1.2.4). This section seems to mix up:

- The internet, which is indeed akin to the printing press
- Word processing and such
- Computational literacy

"We see coding as a new way for people to organize, express, and share
their ideas."

What exactly does this sharing look like? It's relevant for
scientists, but that was already covered in "computational thinking".
Is it people programming in spreadsheets that they share? What do
actual example look like?

> animated greeting cards
> spreadsheet formulas
> tweaking/appreciating websites
> musicians using MaxMSP

### A Confusion

Pg. 37: What is "process" here? Earlier in the book, it was *defined*
as being what a program does, but here it's supposed to be broader
than CS.

### A Surprise

Apparently LOGO taught poorly. I'm curious to see the studies that
killed it, what the language's aims were and what the results were.
(My guess: the aims presented for LOGO were way out of whack with what
one could reasonably expect to learn from the language.)
